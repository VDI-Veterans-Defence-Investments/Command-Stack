# Command-Stack

A command and control ontolog that speeds decision making to action in autonomy...

# AIM

To deliver an all-encompassing objective, asset, and game surface tactical command and control system native to Augementation AI not Full Autonomy for software advisers or agents assisting humans.

After tiresome idiotic command and control architectures that were seemingly made by people that don't make effective command and control (one that fails to make anything clearly able to command anything in the same way ) that is simple, clear, all-inclusive, and compressed, I decided to make a public repository. This system can be installed in from video games to C4ISR - RSTA cores. The objective is to make a system that responds in real time with graceful degradation of performance. This isn't a C4ISR system in a box it is a way to obviate the need for one by allowing all meshed networked elements to deliver comparatively through dispersed ideation (coalescent model understanding) and and goal vector shaping with and without promise theory.

The way that this is different and can be used anywhere from devices to military organizations hinges on stratification. Designs must be custom optimized from a source and hardware core into effective systems with real specifications and assuring critical requirements.

# How?

The goals or objectives, the assets, the kinds of positions and poses, and the mechanisms are all separated onto single dimensions and/or stratified along solitude spaces that can be stitched together to make metric spaces of various capabilities. This isn't bound by one-dimensional, two-dimensional, and up. The notion is to expand spatial reasoning across many volumetric spaces (in the coordinate affine space way) as well as non-numerics like semiotics. 

Here's the secret: most model generation systems have an inherent command and control schema inherent in the code architecture. This one allows one to parameterize and adapt using any scale of augmentation how complicated the model generation and promulgation will be. 

The way you keep it effective is write the code near assembly and exploit advantages like CPU intrinsics rather than GPUs.

# What will it Take?

Majority leveraged code. Lots of scanning and scraping, leading to haphazard inclusions. Most coders don't understand they end up rewriting in part or whole what's already there.

Read [Untrapped Value: 1.01 Software Reuse Powering Future Prosperity](https://play.google.com/store/books/details/Untrapped_Value_1_01_Software_Reuse_Powering_Futur) for an explanation of why and how I do it.  

If anyone wants a customized system that's optimized for any code base destined for a specific firmware/hardware architecture, I can architect what and where that would take, and the cost. 


# Working Within/Without Metric Spaces And Semiotic Spaces

Metric spaces have defined mathematical elements and defined mechanisms. In this stack, the ways eventualities are calculated can be defined as unique or ubiquitous. They don't NEED to be arithmetic spaces as you were taught in schools but those form the basis because sometimes a qualitative tinge o

The commands, objectives, and assets are delivered by way of three interlocking processes (the process might be a human operator inputting data, an algorithm, thread, process, processor, GPU, CPU core, or custom ASIC hardware) working on complimentary methods while reading and writing to each other's data memories. They are broadly thus:

# FINDER 

# MINDER

# GRINDER


